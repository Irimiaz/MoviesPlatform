# MoviesPlatform

The idea of this project is to simulate an interface of a site such as Netflix through which the user can interact with different movies and also be able to log in or authenticate. My main class is the one called PLATFORM which is instantiated using Singleton. In this class there are details and general information about the entire platform (such as all the movies that are available, the current user or the current page where the user is).

In the "platform" package, there are also classes such as User or Movie, which have the role of storing information about users or movies. Input and output classes are very important because it provide and display the information in the form of Json and facilitate data processing, entering them into classes. The classes MovieInputToUser and UserInputToUser are then used to convert the data from the Input form to the Movie class form, respectively User or vice-versa.

In the "input" package, there are several classes that help provide all the input data and put them in a single general class, which will be used in the main class.

In the "actions" package there are several classes such as "Filter" "Change Page" "Purchase" "Login" which simply represent the action desired by the user. Within these classes there is the logic behind the entire project. Action information is stored in classes to make the code better structured.

All these actions have the same parameters because the Factory Design Pattern is used to call a general function, called "basic action" regardless of the desired functionality. Within the "ActionFactory" class is the logic for transforming the "basicAction" functions into the functions we want, taking into account the names of the input functions.

The Main class is the one that goes through all the actions and uses the input to send further commands. It will go through each action separately and call the functions from the "actions" package. Depending on the result of these calls, different outputs (error or desired display) will be sent to the user.

In the Subscribe class from the "Actions" package, I added a new genre to the subscribedGenres array.
This array of genres will help us with the Oberserver Design Pattern when we call Database add or delete, because we will know where the oberservers will act.

Database add and delete are two functions that add or delete movies from the database. In addition to modifying the database, all affected users will receive a notification. With this modification of the database, if a movie is deleted from the database but was bought, viewed, etc. by a user, it disappears from all these arrays. We implemented these functions using the Obeserver Design Pattern because once the Database is modified, several actions are produced synchronously. All the observations we need are instantiated and they are all updated instantly. For example, for data, two different observers will be instantiated, one that will insert a new notification notifying users that a movie has been deleted, and the second one will delete the movie from the subject everywhere. All these classes and interfaces are in the observers package.

The back action between pages is exactly the opposite of the change page, because users also need to return to a previous page. In order not to have to remember for each change page and the page we started from, we used the Command design pattern which has the role of remembering the list of commands performed on an object. This design pattern is perfect for creating delegation and callback structures. When you want to change the page, the previous page will also be memorized so that the back function can be used at a given moment.The Editor class is used, which contains a "history" array, which is a stack containing all page changes. Using this stack, we can use the function of back without parameters because, with the help of the pop function in the stack, we will know what was the last page change.

For the user recommendation function, a simple search for a desired movie in the database is used. This class is in the "Actions" package. I sorted all the genres of movies bought by the user according to the number of likes. I sorted all the movies in the database according to the rate received. Having these two sorts, we look for the first movie that has one of the genres, a genre preferred by the user. This information will be sent to the user in the form of a notification.
